{"version":3,"sources":["config.js","pathToRegexp.js","router.js","route.js","link.js","redirect.js"],"names":["dmx","config","mapping","parse","str","options","res","tokens","key","index","path","defaultDelimiter","delimiter","PATH_REGEXP","exec","m","escaped","offset","slice","length","next","prefix","name","capture","group","modifier","asterisk","push","partial","repeat","optional","pattern","escapeGroup","escapeString","substr","compile","tokensToFunction","encodeURIComponentPretty","encodeURI","replace","c","charCodeAt","toString","toUpperCase","encodeAsterisk","matches","Array","i","RegExp","obj","opts","data","encode","pretty","encodeURIComponent","token","segment","value","TypeError","isarray","JSON","stringify","j","test","attachKeys","re","keys","flags","sensitive","regexpToRegexp","groups","source","match","arrayToRegexp","parts","pathToRegexp","regexp","join","stringToRegexp","tokensToRegExp","strict","end","route","endsWithDelimiter","isArray","Component","constructor","node","parent","router","console","warn","this","BaseComponent","call","initialData","pathname","search","query","tag","attributes","base","type","String","default","history","Boolean","methods","navigate","url","render","props","document","location","set","hash","split","reduce","params","param","p","prototype","update","qs","Object","assign","map","info","pushState","isExact","isMatch","exact","template","createElement","innerHTML","$node","$parse","parentNode","appendChild","removeChild","addEventListener","bind","event","getAttribute","preventDefault","from","to"],"mappings":"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","file":"../components/dmxRouting.js","sourcesContent":["dmx.config.mapping['a'] = 'link';\r\n","(function() {\r\n\r\n// EDITED: use native Array.isArray\r\n// var isarray = require('isarray')\r\nvar isarray = Array.isArray;\r\n\r\n// EDITED: attach to our dmx namespace\r\n/**\r\n * Expose `pathToRegexp`.\r\n */\r\n// module.exports = pathToRegexp\r\n// module.exports.parse = parse\r\n// module.exports.compile = compile\r\n// module.exports.tokensToFunction = tokensToFunction\r\n// module.exports.tokensToRegExp = tokensToRegExp\r\ndmx.pathToRegexp = pathToRegexp;\r\ndmx.pathToRegexp.parse = parse;\r\ndmx.pathToRegexp.compile = compile;\r\ndmx.pathToRegexp.tokensToFunction = tokensToFunction;\r\ndmx.pathToRegexp.tokensToRegExp = tokensToRegExp;\r\n\r\n/**\r\n * The main path matching regexp utility.\r\n *\r\n * @type {RegExp}\r\n */\r\nvar PATH_REGEXP = new RegExp([\r\n  // Match escaped characters that would otherwise appear in future matches.\r\n  // This allows the user to escape special characters that won't transform.\r\n  '(\\\\\\\\.)',\r\n  // Match Express-style parameters and un-named parameters with a prefix\r\n  // and optional suffixes. Matches appear as:\r\n  //\r\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\r\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\r\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\r\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\r\n].join('|'), 'g')\r\n\r\n/**\r\n * Parse a string for the raw tokens.\r\n *\r\n * @param  {string}  str\r\n * @param  {Object=} options\r\n * @return {!Array}\r\n */\r\nfunction parse (str, options) {\r\n  var tokens = []\r\n  var key = 0\r\n  var index = 0\r\n  var path = ''\r\n  var defaultDelimiter = options && options.delimiter || '/'\r\n  var res\r\n\r\n  while ((res = PATH_REGEXP.exec(str)) != null) {\r\n    var m = res[0]\r\n    var escaped = res[1]\r\n    var offset = res.index\r\n    path += str.slice(index, offset)\r\n    index = offset + m.length\r\n\r\n    // Ignore already escaped sequences.\r\n    if (escaped) {\r\n      path += escaped[1]\r\n      continue\r\n    }\r\n\r\n    var next = str[index]\r\n    var prefix = res[2]\r\n    var name = res[3]\r\n    var capture = res[4]\r\n    var group = res[5]\r\n    var modifier = res[6]\r\n    var asterisk = res[7]\r\n\r\n    // Push the current path onto the tokens.\r\n    if (path) {\r\n      tokens.push(path)\r\n      path = ''\r\n    }\r\n\r\n    var partial = prefix != null && next != null && next !== prefix\r\n    var repeat = modifier === '+' || modifier === '*'\r\n    var optional = modifier === '?' || modifier === '*'\r\n    var delimiter = res[2] || defaultDelimiter\r\n    var pattern = capture || group\r\n\r\n    tokens.push({\r\n      name: name || key++,\r\n      prefix: prefix || '',\r\n      delimiter: delimiter,\r\n      optional: optional,\r\n      repeat: repeat,\r\n      partial: partial,\r\n      asterisk: !!asterisk,\r\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\r\n    })\r\n  }\r\n\r\n  // Match any characters still remaining.\r\n  if (index < str.length) {\r\n    path += str.substr(index)\r\n  }\r\n\r\n  // If the path exists, push it onto the end.\r\n  if (path) {\r\n    tokens.push(path)\r\n  }\r\n\r\n  return tokens\r\n}\r\n\r\n/**\r\n * Compile a string to a template function for the path.\r\n *\r\n * @param  {string}             str\r\n * @param  {Object=}            options\r\n * @return {!function(Object=, Object=)}\r\n */\r\nfunction compile (str, options) {\r\n  return tokensToFunction(parse(str, options))\r\n}\r\n\r\n/**\r\n * Prettier encoding of URI path segments.\r\n *\r\n * @param  {string}\r\n * @return {string}\r\n */\r\nfunction encodeURIComponentPretty (str) {\r\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\r\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\r\n  })\r\n}\r\n\r\n/**\r\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\r\n *\r\n * @param  {string}\r\n * @return {string}\r\n */\r\nfunction encodeAsterisk (str) {\r\n  return encodeURI(str).replace(/[?#]/g, function (c) {\r\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\r\n  })\r\n}\r\n\r\n/**\r\n * Expose a method for transforming tokens into the path function.\r\n */\r\nfunction tokensToFunction (tokens) {\r\n  // Compile all the tokens into regexps.\r\n  var matches = new Array(tokens.length)\r\n\r\n  // Compile all the patterns before compilation.\r\n  for (var i = 0; i < tokens.length; i++) {\r\n    if (typeof tokens[i] === 'object') {\r\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\r\n    }\r\n  }\r\n\r\n  return function (obj, opts) {\r\n    var path = ''\r\n    var data = obj || {}\r\n    var options = opts || {}\r\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\r\n\r\n    for (var i = 0; i < tokens.length; i++) {\r\n      var token = tokens[i]\r\n\r\n      if (typeof token === 'string') {\r\n        path += token\r\n\r\n        continue\r\n      }\r\n\r\n      var value = data[token.name]\r\n      var segment\r\n\r\n      if (value == null) {\r\n        if (token.optional) {\r\n          // Prepend partial segment prefixes.\r\n          if (token.partial) {\r\n            path += token.prefix\r\n          }\r\n\r\n          continue\r\n        } else {\r\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\r\n        }\r\n      }\r\n\r\n      if (isarray(value)) {\r\n        if (!token.repeat) {\r\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\r\n        }\r\n\r\n        if (value.length === 0) {\r\n          if (token.optional) {\r\n            continue\r\n          } else {\r\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\r\n          }\r\n        }\r\n\r\n        for (var j = 0; j < value.length; j++) {\r\n          segment = encode(value[j])\r\n\r\n          if (!matches[i].test(segment)) {\r\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\r\n          }\r\n\r\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\r\n        }\r\n\r\n        continue\r\n      }\r\n\r\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\r\n\r\n      if (!matches[i].test(segment)) {\r\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\r\n      }\r\n\r\n      path += token.prefix + segment\r\n    }\r\n\r\n    return path\r\n  }\r\n}\r\n\r\n/**\r\n * Escape a regular expression string.\r\n *\r\n * @param  {string} str\r\n * @return {string}\r\n */\r\nfunction escapeString (str) {\r\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\r\n}\r\n\r\n/**\r\n * Escape the capturing group by escaping special characters and meaning.\r\n *\r\n * @param  {string} group\r\n * @return {string}\r\n */\r\nfunction escapeGroup (group) {\r\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\r\n}\r\n\r\n/**\r\n * Attach the keys as a property of the regexp.\r\n *\r\n * @param  {!RegExp} re\r\n * @param  {Array}   keys\r\n * @return {!RegExp}\r\n */\r\nfunction attachKeys (re, keys) {\r\n  re.keys = keys\r\n  return re\r\n}\r\n\r\n/**\r\n * Get the flags for a regexp from the options.\r\n *\r\n * @param  {Object} options\r\n * @return {string}\r\n */\r\nfunction flags (options) {\r\n  return options.sensitive ? '' : 'i'\r\n}\r\n\r\n/**\r\n * Pull out keys from a regexp.\r\n *\r\n * @param  {!RegExp} path\r\n * @param  {!Array}  keys\r\n * @return {!RegExp}\r\n */\r\nfunction regexpToRegexp (path, keys) {\r\n  // Use a negative lookahead to match only capturing groups.\r\n  var groups = path.source.match(/\\((?!\\?)/g)\r\n\r\n  if (groups) {\r\n    for (var i = 0; i < groups.length; i++) {\r\n      keys.push({\r\n        name: i,\r\n        prefix: null,\r\n        delimiter: null,\r\n        optional: false,\r\n        repeat: false,\r\n        partial: false,\r\n        asterisk: false,\r\n        pattern: null\r\n      })\r\n    }\r\n  }\r\n\r\n  return attachKeys(path, keys)\r\n}\r\n\r\n/**\r\n * Transform an array into a regexp.\r\n *\r\n * @param  {!Array}  path\r\n * @param  {Array}   keys\r\n * @param  {!Object} options\r\n * @return {!RegExp}\r\n */\r\nfunction arrayToRegexp (path, keys, options) {\r\n  var parts = []\r\n\r\n  for (var i = 0; i < path.length; i++) {\r\n    parts.push(pathToRegexp(path[i], keys, options).source)\r\n  }\r\n\r\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\r\n\r\n  return attachKeys(regexp, keys)\r\n}\r\n\r\n/**\r\n * Create a path regexp from string input.\r\n *\r\n * @param  {string}  path\r\n * @param  {!Array}  keys\r\n * @param  {!Object} options\r\n * @return {!RegExp}\r\n */\r\nfunction stringToRegexp (path, keys, options) {\r\n  return tokensToRegExp(parse(path, options), keys, options)\r\n}\r\n\r\n/**\r\n * Expose a function for taking tokens and returning a RegExp.\r\n *\r\n * @param  {!Array}          tokens\r\n * @param  {(Array|Object)=} keys\r\n * @param  {Object=}         options\r\n * @return {!RegExp}\r\n */\r\nfunction tokensToRegExp (tokens, keys, options) {\r\n  if (!isarray(keys)) {\r\n    options = /** @type {!Object} */ (keys || options)\r\n    keys = []\r\n  }\r\n\r\n  options = options || {}\r\n\r\n  var strict = options.strict\r\n  var end = options.end !== false\r\n  var route = ''\r\n\r\n  // Iterate over the tokens and create our regexp string.\r\n  for (var i = 0; i < tokens.length; i++) {\r\n    var token = tokens[i]\r\n\r\n    if (typeof token === 'string') {\r\n      route += escapeString(token)\r\n    } else {\r\n      var prefix = escapeString(token.prefix)\r\n      var capture = '(?:' + token.pattern + ')'\r\n\r\n      keys.push(token)\r\n\r\n      if (token.repeat) {\r\n        capture += '(?:' + prefix + capture + ')*'\r\n      }\r\n\r\n      if (token.optional) {\r\n        if (!token.partial) {\r\n          capture = '(?:' + prefix + '(' + capture + '))?'\r\n        } else {\r\n          capture = prefix + '(' + capture + ')?'\r\n        }\r\n      } else {\r\n        capture = prefix + '(' + capture + ')'\r\n      }\r\n\r\n      route += capture\r\n    }\r\n  }\r\n\r\n  var delimiter = escapeString(options.delimiter || '/')\r\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\r\n\r\n  // In non-strict mode we allow a slash at the end of match. If the path to\r\n  // match already ends with a slash, we remove it for consistency. The slash\r\n  // is valid at the end of a path match, not in the middle. This is important\r\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\r\n  if (!strict) {\r\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\r\n  }\r\n\r\n  if (end) {\r\n    route += '$'\r\n  } else {\r\n    // In non-ending mode, we need the capturing groups to match as much as\r\n    // possible by using a positive lookahead to the end or next path segment.\r\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\r\n  }\r\n\r\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\r\n}\r\n\r\n/**\r\n * Normalize the given path string, returning a regular expression.\r\n *\r\n * An empty array can be passed in for the keys, which will hold the\r\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\r\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\r\n *\r\n * @param  {(string|RegExp|Array)} path\r\n * @param  {(Array|Object)=}       keys\r\n * @param  {Object=}               options\r\n * @return {!RegExp}\r\n */\r\nfunction pathToRegexp (path, keys, options) {\r\n  if (!isarray(keys)) {\r\n    options = /** @type {!Object} */ (keys || options)\r\n    keys = []\r\n  }\r\n\r\n  options = options || {}\r\n\r\n  if (path instanceof RegExp) {\r\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\r\n  }\r\n\r\n  if (isarray(path)) {\r\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\r\n  }\r\n\r\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\r\n}\r\n\r\n})();\r\n","dmx.Component('router', {\r\n\r\n    constructor: function(node, parent) {\r\n        if (dmx.router) {\r\n            console.warn('An other router already registered!');\r\n            return;\r\n        }\r\n\r\n        dmx.router = this;\r\n        dmx.BaseComponent.call(this, node, parent);\r\n    },\r\n\r\n    initialData: {\r\n        pathname: '/',\r\n        search: '',\r\n        query: {}\r\n    },\r\n\r\n    tag: 'div',\r\n\r\n    attributes: {\r\n        base: {\r\n            type: String,\r\n            default: '/'\r\n        },\r\n\r\n        history: {\r\n            type: Boolean,\r\n            default: false\r\n        }\r\n    },\r\n\r\n    methods: {\r\n        navigate: function(url, query) {\r\n            this.navigate(url, query);\r\n        }\r\n    },\r\n\r\n    render: function(node) {\r\n        if (this.props.history) {\r\n            var pathname = document.location.pathname;\r\n            if (this.props.base) pathname = pathname.replace(new RegExp('^' + this.props.base), '/');\r\n            this.set('pathname', pathname);\r\n            this.set('search', document.location.search);\r\n        } else {\r\n            var parts = document.location.hash.substr(1).split('?');\r\n            this.set('pathname', parts[0] || '/');\r\n            this.set('search', parts[1] ? '?' + parts[1] : '');\r\n        }\r\n        this.set('query', this.data.search.substr(1).split('&').reduce(function(params, param) {\r\n            var p = param.split('=');\r\n            if (p[0]) params[p[0]] = p[1] ? p[1] : true;\r\n            return params;\r\n        }, {}));\r\n        dmx.BaseComponent.prototype.render.call(this, node);\r\n    },\r\n\r\n    update: function() {\r\n        if (this.props.history) {\r\n            var pathname = document.location.pathname;\r\n            if (this.props.base) pathname = pathname.replace(new RegExp('^' + this.props.base), '/');\r\n            this.set('pathname', pathname);\r\n            this.set('search', document.location.search);\r\n        } else {\r\n            var parts = document.location.hash.substr(1).split('?');\r\n            this.set('pathname', parts[0] || '/');\r\n            this.set('search', parts[1] ? '?' + parts[1] : '');\r\n        }\r\n        this.set('query', this.data.search.substr(1).split('&').reduce(function(params, param) {\r\n            var p = param.split('=');\r\n            if (p[0]) params[p[0]] = p[1] ? p[1] : true;\r\n            return params;\r\n        }, {}));\r\n    },\r\n\r\n    navigate: function(url, query) {\r\n        var qs = '';\r\n\r\n        if (query) {\r\n            query = Object.assign({}, this.data.query, query);\r\n\r\n            qs = Object.keys(query).map(function(key) {\r\n                return key + '=' + query[key];\r\n            }).join('&');\r\n\r\n            if (qs) qs = '?' + qs;\r\n        }\r\n\r\n        console.info('navigate to ', url, query);\r\n\r\n        if (this.props.history) {\r\n            history.pushState(null, '', url + qs);\r\n        } else {\r\n            document.location.hash = url + qs;\r\n        }\r\n    }\r\n\r\n});\r\n","dmx.Component('route', {\r\n\r\n    initialData: {\r\n        params: {}, // Key/value pairs parsed from the URL corresponding to the dynamic segments of the path\r\n        isExact: false,\r\n        isMatch: false,\r\n        path: '', // The path pattern used to match. Useful for building nested Routes\r\n        url: '' // The matched portion of the URL. Useful for building nested Links\r\n    },\r\n\r\n    tag: 'div',\r\n\r\n    attributes: {\r\n        path: {\r\n            type: String,\r\n            default: '*'\r\n        },\r\n\r\n        exact: {\r\n            type: Boolean,\r\n            default: false\r\n        }\r\n    },\r\n\r\n    render: function(node) {\r\n        //dmx.BaseComponent.prototype.render.call(this, node);\r\n\r\n        this.template = document.createElement('div');\r\n        this.template.innerHTML = this.$node.innerHTML;\r\n        this.$node.innerHTML = '';\r\n        this.$parse(this.template);\r\n\r\n        this.keys = [];\r\n        this.re = dmx.pathToRegexp(this.props.path, this.keys, {\r\n            end: this.props.exact\r\n        });\r\n\r\n        this.update();\r\n    },\r\n\r\n    update: function() {\r\n        var match = this.re.exec(dmx.router.data.pathname);\r\n\r\n        this.set('path', this.props.path);\r\n        this.set('isExact', !!this.props.exact);\r\n        this.set('isMatch', !!match);\r\n\r\n        if (match) {\r\n            this.set('url', match[0]);\r\n            this.set('params', this.keys.reduce(function(params, key, index) {\r\n                params[key.name] = match[index + 1];\r\n                return params;\r\n            }, {}));\r\n\r\n            if (!this.template.parentNode) {\r\n                this.$node.appendChild(this.template);\r\n            }\r\n        } else {\r\n            this.set('url', '');\r\n            this.set('params', {});\r\n            if (this.template.parentNode) {\r\n                this.$node.removeChild(this.template);\r\n            }\r\n        }\r\n    }\r\n\r\n});\r\n","dmx.Component('link', {\r\n\r\n    tag: 'a',\r\n\r\n    render: function(node) {\r\n        dmx.BaseComponent.prototype.render.call(this, node);\r\n        if (dmx.router) {\r\n            this.$node.addEventListener('click', this.navigate.bind(this));\r\n        }\r\n    },\r\n\r\n    navigate: function(event) {\r\n        var url = this.$node.getAttribute('href');\r\n\r\n        if (url[0] == '/' && url[1] != '/') {\r\n            event.preventDefault();\r\n            dmx.router.navigate(url);\r\n        }\r\n    }\r\n\r\n});\r\n","dmx.Component('redirect', {\r\n\r\n    attributes: {\r\n        from: {\r\n            type: String,\r\n            default: '*'\r\n        },\r\n\r\n        to: {\r\n            type: String,\r\n            default: ''\r\n        }\r\n    },\r\n\r\n    render: function(node) {\r\n        if (!dmx.router) {\r\n            console.warn('No router is registered!');\r\n            return;\r\n        }\r\n\r\n        if (!this.props.to) {\r\n            console.warn('Missing to prop on redirect!');\r\n            return;\r\n        }\r\n\r\n        this.keys = [];\r\n        this.re = dmx.pathToRegexp(this.props.from, this.keys, {\r\n            end: true\r\n        });\r\n\r\n        this.update();\r\n    },\r\n\r\n    update: function() {\r\n        var match = this.re.exec(dmx.router.data.pathname);\r\n\r\n        if (match) {\r\n            dmx.router.navigate(this.props.to);\r\n        }\r\n    }\r\n\r\n});\r\n"]}